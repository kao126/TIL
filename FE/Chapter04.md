## 4-1 アルゴリズム ☆
- アルゴリズム：何らかの問題を有限の時間で解くための手順のこと
- 変数：データを格納する領域
- フローチャート：流れ図。アルゴリズムを記述する方法
  - 制御構造
    1. 順次：Aの次にBをする
    2. 選択：もしCだったらDをする
    4. 繰返し：Eになるまで繰り返す
- 構造化プログラミング：プログラム全体を機能ごとに分割し、処理の制御構造としては、順次・選択・繰返しだけを用いることを原則とするプログラミング手法
- トレース：アルゴリズムをたどって変数の変化を追跡すること
- 決定表：条件とその条件に対する動作とを表形式に整理したもの


## 4-2 配列 ☆
- データ構造：データを効率よく管理するための形式
- 配列：同じデータ型（数値型、文字列型、論理型など）の複数の要素が連続してまとまったデータ構造
  - 1次元配列：一つの添字
  - 2次元配列：二つの添字（行と列）

> 「配列」とくれば「添字を用いてデータを取得するデータ構造」


## 4-3 リスト ◎
- **リスト**：データを記録するデータ部とデータの格納位置を示すポインタ部で構成されるデータ構造
  - リスト構造の種類
    - 単方向リスト
    - 双方向リスト
    - 環状リスト
> 「リスト」とくれば「ポインタをたどってデータを取得するデータ構造」


## 4-4 キューとスタック ☆
- **キュー**：格納した順序でデータを取り出すことができるデータ構造（FIFO）
  - エンキュー(enqueue)：キューにデータを格納すること
  - デキュー(dequeue)：キューからデータを取り出すこと
> 「キュー」とくれば「先に格納したデータから先に取り出すデータ構造(FIFO)」

- **スタック**：格納した順序とは逆の順序でデータを取り出すことができるデータ構造（LIFO）
  - プッシュ(push)：スタックにデータを格納すること
  - ポップ(pop)：スタックからデータを取り出すこと
> 「スタック」とくれば「後に格納したデータから先に取り出すデータ構造(LIFO)」


## 4-5 木構造 ◎
- **木構造**：階層の上位から下位に節点をたどることによって、データを取り出すことができるデータ構造（ツリー構造）
  - 節（ノード）：○部分
  - 枝（ブランチ）：節と節をつないだ---の部分
  - 根（ルート）：最上位の節
  - 葉（リーフ）：最下位の節
  - 親子関係
    - 親：上位の節
    - 子：下位の節
    - 部分木：節にぶら下がっている部分（左部分木/右部分木）

- 2分木：全ての枝の分岐が二つ以下である木構造
  - **完全二分木**：根から葉までの深さが全て等しい2分木
  - **2分探索木**：各節において、「左の子 < 親 < 右の子」という関係をもった2分木

> 「2分探索木」とくれば「左の子 < 親 < 右の子」

- **ヒープ木**：各節において、「親 < 子」または「親 > 子」という関係をもった完全2分木
> 「ヒープ木」とくれば「親 < 子（根が最小値）。または、親 > 子（根が最大値）」

- **逆ポーランド記法**：2分木を使って算術式を表記する方法の一つで、節に演算子、葉に被演算数を配置します。

- B木：枝の分岐が二つ以上あり、データ挿入時は根から葉までの深さが同じ
- B+木：葉にのみデータをもたせます。


## 4-6 データの整列 ◎
- 整列：ある規則に従ってデータを並べ替えること（ソート）
- 代表的な整列法
  - **基本交換法**：隣り合うデータを比較し、逆順であれば入れ替えをする方法
  - **基本選択法**：データ列の最小値（最大値）を選択して入れ替え、次にそれを除いた部分の中から最小値（最大値）を選択して入れ替える方法
  - **基本挿入法**：すでに整列済みのデータ列の正しい位置に、データを挿入する方法
  - シェルソート：ある一定間隔おきに取り出したデータから成るデータ列をそれぞれ整列する
  - **クイックソート**：適当な基準値を決めて、それより小さな値のグループと大きな値のグループにデータを振り分ける
  - ヒープソート：未整列の部分を順序木に構成し、その最大値（最小値）を取り出して、既整列の部分に移す

> 「基本交換法」とくれば「隣り合うデータを比較して入れ替える方法」
> 
> 「基本選択法」とくれば「データ列から最小値（最大値）を選択して入れ替える方法」
> 
> 「基本挿入法」とくれば「整列済みの正しい位置にデータを挿入する方法」
